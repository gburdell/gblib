/*
 * The MIT License
 *
 * Copyright 2017 gburdell.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package gblib;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.sql.Types;
//import javax.json.JsonObject;

/**
 * Top-level interface to facilitate (more) convenient manipulation of
 * databases.
 *
 * @author kpfalzer
 */
public class Model {

    public static int getSqlType(String type) {
        int r = -1;
        switch (type) {
            case "LONG VARCHAR":
                r = Types.LONGVARCHAR;
                break;
            case "TIMESTAMP":
                r = Types.TIMESTAMP;
                break;
            case "INTEGER":
                r = Types.INTEGER;
                break;
            case "REAL":
                r = Types.REAL;
                break;
            case "CHAR":
                r = Types.CHAR;
                break;
            default:
                assert false;
        }
        return r;
    }

    public Model(String tblName, boolean idIsAutoGend) {
        m_tblName = tblName;
        m_idIsAutoGend = idIsAutoGend;
        if (null == m_dbUrl) {
            try {
                /*todo
                m_dbUrl = ann(getProperty(DB_URL));
                m_dbUname = ann(getProperty(DB_UNAME));
                m_dbPasswd = ann(getProperty(DB_PASSWD));
                 */
            } catch (Exception ex) {
                //todo exit(ex);
            }
        }
        setup();
    }

    public Model(String tblName) {
        this(tblName, false);
    }

    public String getTableName(boolean fqn) {
        return m_tblName;
    }

    public String getTableName() {
        return m_tblName;
    }

    public String getFullTableName() {
        return getTableName(true);
    }

    /**
     * Insert and return new (inserted) ID.
     *
     * @param vals values to insert.
     * @return new/last ID.
     */
    public synchronized long getNextId(Model.ValMap vals) {
        insert(vals);
        return getNextId();
    }

    protected long getNextId() {
        long id = -1;
        String stmt = "SELECT MAX(ID) FROM " + getFullTableName();
        try (Connection conn = getConnection()) {
            ResultSet rs = createStatement(conn).executeQuery(stmt);
            boolean b = rs.first();
            assert b;
            id = rs.getLong(1);
        } catch (SQLException ex) {
            //todo Logger.getLogger(IdTable.class.getName()).log(Level.SEVERE, null, ex);
        }
        return id;
    }

    public boolean idIsAutoGenerated() {
        return m_idIsAutoGend;
    }

    /**
     * Insert key/value set into dbase (i.e., Object Relational Mapping).
     *
     * @param kvs json-type map.
     */
    /*
    public void insert(final JsonObject kvs) {
        ValMap valMap = new ValMap();
        String val;
        for (String key : kvs.keySet()) {
            val = kvs.get(key).toString();
            key = key.toUpperCase();
            assert !valMap.containsKey(key);
            valMap.put(key, val);
        }
        insert(valMap);
    }
     */
    
    public void insert(final ValMap kvs) {
        assert !kvs.isEmpty();  //cant have empty table
        try {
            StringBuilder cmd = new StringBuilder("INSERT INTO ");
            cmd.append(getFullTableName()).append(" (");
            StringBuilder vals = new StringBuilder(") VALUES (");
            char comma = ' ';
            String colNm;
            PosType posType;
            String val, val2;
            for (Map.Entry<String, PosType> e : m_colInfo.entrySet()) {
                colNm = e.getKey();
                val = kvs.get(colNm);
                if (null != val) {
                    posType = e.getValue();
                    val2 = asString(val, posType.v2);
                    if (null != val2) {
                        cmd.append(comma).append(colNm);
                        vals.append(comma).append(val2);
                        comma = ',';
                    }
                }
            }
            cmd.append(vals).append(")");
            String sql = cmd.toString();
            try (Connection conn = getConnection()) {
                boolean b = createStatement(conn).execute(sql);
                assert !b;
            }
        } catch (SQLException ex) {
            Logger.getLogger(Model.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public static String asString(String val, int type) {
        String r = val;
        switch (type) {
            case Types.LONGVARCHAR:
            case Types.CHAR:
                r = "'" + val.replace("'", "''") + "'";
                break;
            case Types.TIMESTAMP:
                r = null;   //use DEFAULT CURRENT_TIMESTAMP
                break;
            //all other just pass verbatim
        }
        return r;
    }

    private synchronized void setup() {
        if (null == m_colInfo) {
            int coli = 1;
            boolean doComma = false;
            try (Connection conn = getConnection()) {
                ResultSet rs = conn.getMetaData().getColumns(null, null, getTableName(), "%");
                String colNm, typeNm;
                while (rs.next()) {
                    colNm = rs.getString("COLUMN_NAME").toUpperCase();
                    typeNm = rs.getString("TYPE_NAME").toUpperCase();
                    if (null == m_colInfo) {
                        m_colInfo = new HashMap<>();
                    }
                    assert !m_colInfo.containsKey(colNm);
                    m_colInfo.put(colNm, new PosType(coli, typeNm));
                    coli++;
                }
            } catch (Exception ex) {
                Util.abnormalExit(ex);
            }
            assert null == m_selectStmt;
            m_selectStmt = "SELECT * FROM " + getFullTableName() + " WHERE ID=";
        }
    }

    public static Statement createStatement(Connection conn) throws SQLException {
        return conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                ResultSet.CONCUR_READ_ONLY);
    }

    /**
     * Get column type.
     *
     * @param colnm column name.
     * @return sql.Types value for valid colnm, else NULL (type).
     */
    public int getColType(String colnm) {
        colnm = colnm.toUpperCase();
        return (m_colInfo.containsKey(colnm)) ? m_colInfo.get(colnm).v2 : Types.NULL;
    }

    public static Connection getConnection() throws SQLException {
        Connection conn = DriverManager.getConnection(m_dbUrl, m_dbUname, m_dbPasswd);
        conn.setAutoCommit(true);
        PreparedStatement ps = getPreparedStatement(conn, "set schema ?");
        ps.setString(1, DFLT_SCHEMA);
        ps.executeUpdate();
        return conn;
    }

    public static PreparedStatement getPreparedStatement(Connection conn, String stmt) throws SQLException {
        return conn.prepareStatement(stmt);
    }

    /**
     * Column index and type.
     */
    public static class PosType extends Pair<Integer, Integer> {

        public PosType(int col, String type) {
            super(col, getSqlType(type));
        }
    }

    /**
     * Wrap value as Java representation of SqlType.
     */
    public static class SqlVal {

        public SqlVal(char s[]) {
            m_sqlType = Types.CHAR;
            m_val = s;
        }

        public SqlVal(String s) {
            m_sqlType = Types.LONGVARCHAR;
            m_val = s;
        }

        public void set(String s) {
            assert (m_sqlType == Types.LONGVARCHAR || m_sqlType == Types.CHAR);
            m_val = s;
        }

        public SqlVal(float s) {
            m_sqlType = Types.REAL;
            m_val = s;
        }

        public SqlVal(final ResultSet rs, int col) throws SQLException {
            m_sqlType = rs.getMetaData().getColumnType(col);
            switch (m_sqlType) {
                case Types.INTEGER:
                    m_val = rs.getLong(col);
                    break;
                case Types.LONGVARCHAR:
                case Types.CHAR:
                    m_val = rs.getString(col);
                    break;
                case Types.TIMESTAMP:
                    m_val = rs.getTimestamp(col);
                    break;
                case Types.REAL:
                    m_val = rs.getFloat(col);
                    break;
                default:
                    assert false;
            }
        }

        public SqlVal(final ResultSet rs, String col, int sqlType) throws SQLException {
            m_sqlType = sqlType;
            switch (m_sqlType) {
                case Types.INTEGER:
                    m_val = rs.getLong(col);
                    break;
                case Types.LONGVARCHAR:
                case Types.CHAR:
                    m_val = rs.getString(col);
                    break;
                case Types.TIMESTAMP:
                    m_val = rs.getTimestamp(col);
                    break;
                case Types.REAL:
                    m_val = rs.getFloat(col);
                    break;
                default:
                    assert false;
            }
        }

        public Long asLong() {
            return (Long) m_val;
        }

        public Timestamp asTimeStamp() {
            return (Timestamp) m_val;
        }

        public String asString() {
            return (String) m_val;
        }

        public Float asFloat() {
            return (Float) m_val;
        }

        public final static String EMPTY = "";

        @Override
        public String toString() {
            return (m_val != null) ? m_val.toString() : EMPTY;
        }

        public int getType() {
            return m_sqlType;
        }
        private final int m_sqlType;
        private Object m_val = false;
    }

    /**
     * Map of key/column to String value.
     */
    public static class ValMap extends HashMap<String, String> {

        public ValMap() {
        }

        /**
         * Create new ValMap and initialize with map.
         *
         * @param map initialize new ValMap. Keys in this map become uppercase
         * keys in ValMap.
         */
        public ValMap(Map<String, String> map) {
            for (String key : map.keySet()) {
                super.put(key.toUpperCase(), map.get(key));
            }
        }
    }

    public static class SqlValMap extends HashMap<String, SqlVal> {

        public SqlValMap() {
        }

        public String getVal(final String key) {
            return super.get(key).toString();
        }
    }

    private final boolean m_idIsAutoGend;
    private HashMap<String, PosType> m_colInfo = null;
    private static final String DFLT_SCHEMA = "APP";
    private String m_selectStmt;
    private final String m_tblName;
    private static String m_dbUrl = null;
    private static String m_dbUname = null;
    private static String m_dbPasswd = null;
    /// Keys into property file.
    public static final String DB_URL = "model.dbUrl";
    public static final String DB_UNAME = "model.dbUname";
    public static final String DB_PASSWD = "model.dbPasswd";
}
